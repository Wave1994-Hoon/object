## SOLID 원칙
### SRP - 단일책익
### OCP - 개발폐쇄
### LSP - 업스캐팅 안전
### ISP - 인터페이스 분리
### DIP - 다운캐스팅 금지

## 객체망
### 메시지가 수신 되었는지가 우리의 주요한 목표이다.
- 객체망에서 테스트해야하는 것은 메시지가 잘 전파되고 수신되었는가
- 실제 작동은 중요하지 않다.

### 두 원칙을 지키면 해당 객체와 메세지를 주고 받는 것은 가능하나 내부를 들여다볼 방법이 없음
- 결국 객체가 제대로 동작하는가를 테스트하려면 
- (1) 객체통신망에서 테스트할 객체에게 메시지를 보낸 뒤
- (2) 그 객체가 이웃 객체에게 메시지를 잘 보냈는지 확인
- (3) 3번을 위해 통신한 이웃 객체를 조사하면 된다.

### Mock 객체를 활용한 검증
객체망에 대한 검증을 하기 위해서는 Mock 객체가 필요하다.

대상 객체가 제대로 통신하는지 검증이 필요하다.

mockery(모조객체) - 테스트 관리 객체 (context)

mock(목객체) - 테스트용 모의객체

![image](https://user-images.githubusercontent.com/60383031/209930629-226ceb81-3021-45d1-b03d-53f36e1f54ed.png)

런타임에 맞춘 메시지를 생성하여 테스트

<br>

## Information Expert
해당 정보를 갖고 있는 객체에게 책임을 할당하라 

객체의 본질과 데이터를 은닉을 지킬 수 있는 패턴

### Creator
객체 시스템의 이질적인 부분을 생성 시에도 정보전문가 패턴을 따르자

어떤 객체가 대상을 포함하거나, 이용하거나, 부분으로 삼거나, 잘 알고 있다면 그 대상을 생성하게 시키자.

### Controller
미디에이터 패턴 설계의 확장으로 서브시스템을 묶을 수 있다면 컨트롤러를 도입하자

(어댑터와 미디에이터가 동시에 필요한 경우 ??)

### Low Coupling & High Cohension
결합도를 낮추고 응집도를 높이는 패턴은 다른 양상으로 나타남

결합도를 낮추려면 아는 객체 수를 줄여야 함, 하지만 더 중요한 것은 단방향 의존성임 

이에 비해 응집도를 높이려면 객체를 도출할 때부터 변화율을 고려해야 함

### Protected Variations
추상적인 수준에서 책임을 정의하여 다양한 구상가능성으로부터 사용할 모듈을 보호하라

### Polymorphism
전략패턴처럼 분기가 예상되는 책임이라면 다형성을 이용하라
