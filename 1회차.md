## 합리성 ?
![image](https://user-images.githubusercontent.com/60383031/204104182-a065ab80-a46c-488b-8efa-8ddebf47f2cc.png)


간단하게 짜야 유연성을 얻는다.


객체지향 진영에서 유일하게 제시하는 한 가지 방법은 역할모델이다.

역할모델 이외에는 어떠한 도메인을 격리시킬 수 있는 수단을 발견하지 못 했다.

<br>

## 추상화
역할 모델을 이해하려면 추상화에 대한 이해가 필요하다

- 일반화(Genralization) - modeling, function, algorithm
- 연관화(Association) - reference, dependence <- 위임 가능
- 집단화(Aggregation) - group, category

### 종류
#### Data Abstration
- Modeling: 특정 목표에 따라 기억하고 싶은 것만 추린 것
- Categorization
- Grouping: 집합

#### Procedural Abstration
프로시저는 데이터의 처리를 함수에게 양도함을 뜻하는 "고유명사"다.

- Genralization: 일반화를 잘 사용하면 함수를 여러개 만들 필요가 없음
- Capsulization: 캡슐화는 보다 추상적인 행위를 표현한다 (정보은닉과는 다름)

#### OOP Abstration
- Genralization: 인터페이스나 추상클래스로 일반화
- Realization: 인터페이스나 추상클래스를 구현
- Dependency: 인자를 받거나 참조
- Association: 필드들
- Directed Association
- Association
- Composition

<br>

## Timing
프로그램이 실행되는 순간이 언제냐

![image](https://user-images.githubusercontent.com/60383031/204121746-6e69188f-2fc8-4e06-bf99-25dc93f86bee.png)

자바는 최초로 런타임 로딩을 사용하였다.

그래서 실행이될때 모든 것을 메모리에 적재하지 않고 사용이될떄 클래스로더로 불러온다.

그래서 배포할때 첫 요청들은 느렸군아


파일에 있는 변수들은 VTable 로 관리되다가 실제 실행이 될 떄 가상 메모리 주소를 진짜 메모리 주소로 치환한다.

<br>

## Pointer of Pointer
데이형은 데이터가 얼마나 길게 가져가야하는지를 나타냄

![image](https://user-images.githubusercontent.com/60383031/204122184-717f5c30-b094-44e4-8227-274cf824b162.png)

직접 참조는 모든 버그의 원인이다 ....







